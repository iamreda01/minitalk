# minitalk01

Minitalk is a communication program using UNIX signals. It consists of a server that receives messages and a client that sends them. Messages are transmitted bit by bit using SIGUSR1 and SIGUSR2 signals.

Here’s some information that might be helpful to you...

A signal : is a notification that an event has occurred, acting like a software interrupt, it can pause a program’s execution at unpredictable times.

A process can send a signal to another process if its has permission.
A process can also signal itself, but most signals come from the kernel, trigged by event such as :
- Hardware exceptions : like invalid struct, division by 0, or accessing restricted memory.
- User inputs : such as pressing control-C (interrupt a process)

Each signal is represented by a unique small integer, starting form 1. These numbers are defined in <signal.h> with symbolic names SIGxxx (ex. SIGUS1).

Signals are divided into :
- Standard signals : (1-31 on LINUX), used by the kernel for process notifications.
- Realtime signals : which have additional features.

A signal is generated by an event, then delivered to a process, triggering a response. If not yet delivered, it is considered pending.

A process can block signals by adding them to its signal mask. blocked signals stay pending until its unblocked. System call allow a process to modify its signal mask, controlling which signals it wants to block or allow.

Default actions of signals :
- Ignored, terminated, core dump, stopped, resumed.

A program can change the behavior of a signal by setting the disposition of the signal, the program can choose one of the following actions :
- Default action : the signal will behave as it normally would.
- Ignore the signal : the signal will discarded.
- Signal handler : A programmer-defined function is executed when the signal is received.

A Signal handler is a custom function that handles a signal.
To set up a signal handler, the program installs the handler, which means telling the kernel to call the handler when signal is delivered.

In our project we’ll use SIGUSR1 and SIGUSR2, they’re used by process to notify each other of events or for synchronization.
A process can send any signal to another process.

Changing Signal Dispositions :

Unix systems provide two ways of changing the disposition of a signal ( signal(), and sigaction()).
Sigaction() is the preferred way to set signal handlers because it offers more control.

Key difference :
- Signal () signal(): It's a system call that sets a signal handler for a specific signal,  its simpler but unreliable across different UNIX implementations.
- Sigaction () It's a more advanced system call used to define signal handling with greater control, provides more features, like blocking signals during handler execution.

Signal Handlers :
functions executed when a specific signal is delivered to a process.
The signal handler is installed either by signal() or sigaction().
Behavior : The signal handler receives a signal number as an argument (e.g., sig), allowing it to handle different signals in one function.

Sending Signals :

kill() 
One process can send a signal to another process using the kill() system call, which is the analog of the kill shell command. (The term kill was chosen because the default action of most of the signals that were available on early UNIX implementations was to terminate the process.) 

Prototype :
		int kill(pid_t pid, int sig);

The pid argument identifies one or more processes to which the signal specified by sig is to be sent. Four different cases determine how pid is interpreted:

- pid > 0: Signal is sent to the process with that pid.
- pid == 0: Signal is sent to all processes in the same process group.
- pid < -1: Signal is sent to all processes in the process group with ID abs(pid).
- pid == -1: Signal is sent to all processes the caller has permission to signal, except the caller and the init process (PID 1).


Not everyone can send signals to everyone:
- Privileged processes (the ones with special powers) can signal any process.
- The init process (PID 1) is a special case. It’s the heart of the system, so it only listens to signals it’s prepared for.
- Regular processes can send signals to others if their user IDs match. If they don’t, well... no signal for you!

Signal Sets: Grouping Signals Together
When dealing with signals, sometimes you want to manage multiple signals at once, not just one. That's where signal sets come in! Think of them as groups of signals, bundled together, so you can easily control them. There are some key functions that help manage these sets.

- sigemptyset(): Creates an empty signal set (no signals in it).
- sigaddset(): Adds a signal to a se
